#!/usr/bin/env python3
"""
Git Auto Commit - automatic commit creation using AI

Copyright (C) 2025 rozeraf
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <https://www.gnu.org/licenses/>.
"""

import argparse
import logging
import os
import sys
import time
from typing import Optional

from colorama import Fore, Style
from colorama import init as colorama_init
from dotenv import load_dotenv
from halo import Halo

from src import api_client, git_utils

load_dotenv()


def setup_logging(debug: bool = False):
    """Configure logging based on debug flag"""
    level = logging.DEBUG if debug else logging.INFO
    format_str = "%(asctime)s - %(name)s - %(levelname)s - %(message)s" if debug else "%(message)s"

    # Reset any existing handlers
    root = logging.getLogger()
    if root.handlers:
        for handler in root.handlers:
            root.removeHandler(handler)

    logging.basicConfig(
        level=level,
        format=format_str,
        handlers=[logging.StreamHandler(sys.stdout)]
    )

logger = logging.getLogger(__name__)


def show_confirmation(commit_msg: str, description: str | None, skip_confirm: bool = False) -> bool:
    """Shows confirmation before committing with beautiful rounded boxes"""
    
    def get_terminal_width():
        """Get terminal width or fallback to safe default"""
        try:
            import shutil
            width = shutil.get_terminal_size().columns
            return min(width, 100)  # Cap at 100 for better readability
        except:
            return 80  # Safe fallback
    
    def wrap_text(text: str, width: int, first_line: bool = False) -> list[str]:
        """Wrap text to fit within width, preserving words"""
        import textwrap
        # For commit messages, try to keep first line shorter if it's long content
        target_width = width - 4  # Basic padding
        if first_line and len(text) > target_width - 10:  # If content is long
            target_width = min(target_width, 50)  # Limit first line to 50 chars
        return textwrap.wrap(text, width=target_width, break_long_words=True, break_on_hyphens=True)
    
    term_width = get_terminal_width()
    header_width = 20  # Fixed width for header
    
    print(f"\n{Fore.CYAN}{Style.BRIGHT}╭─ Commit Preview ─╮{Style.RESET_ALL}")
    print(f"{Fore.CYAN}│ {Fore.YELLOW}Generated by AI{Style.RESET_ALL}{Fore.CYAN} │{Style.RESET_ALL}")
    print(f"{Fore.CYAN}╰───────────────────╯{Style.RESET_ALL}\n")
    
    # Message box with adaptive width
    msg_lines = []
    first_line = True
    for line in commit_msg.split('\n'):
        wrapped = wrap_text(line, term_width, first_line)
        msg_lines.extend(wrapped)
        first_line = False
    
    # Calculate optimal width for commit message (shorter for long content)
    max_len = max(len(line) for line in msg_lines) if msg_lines else 0
    if len(msg_lines) > 2 or max_len > 50:  # If content is long
        width = min(max(40, min(max_len + 4, 60)), term_width)  # Limit width for readability
    else:
        width = min(max(max_len + 4, 40), term_width)
    
    # Top border with left-aligned "Message" label
    label = "Message"
    label_padding = " " * (4 - len(label) // 2)  # Center the label slightly
    top_border = f"╭─{label_padding}{label}─{'─' * (width - len(label) - 6)}╮"
    print(f"{Style.BRIGHT}{top_border}{Style.RESET_ALL}")
    
    # Content lines with proper padding
    for line in msg_lines:
        padded_line = line.ljust(width - 2)
        print(f"{Style.BRIGHT}│{padded_line}│{Style.RESET_ALL}")
    
    # Bottom border
    print(f"{Style.BRIGHT}╰{'─' * (width - 2)}╯{Style.RESET_ALL}")
    
    # Description box if present - label on left side of border with structured content
    if description:
        print()
        desc_lines = []
        
        # Structure description into sections
        changes = []
        details = []
        current_list = changes
        
        for line in description.split('\n'):
            line = line.strip()
            if line.lower().startswith(('changes:', 'details:', 'impact:', 'notes:')):
                current_list = details
                continue
            if line:
                current_list.append(line)
        
        # Format main changes first
        if changes:
            desc_lines.append("Changes:")
            for line in changes:
                if not line.startswith('-'):
                    line = '- ' + line
                desc_lines.extend(wrap_text(line, term_width))
        
        # Then additional details if any
        if details:
            if changes:  # Add separator if we had changes
                desc_lines.append("")
            desc_lines.append("Details:")
            for line in details:
                if not line.startswith('-'):
                    line = '- ' + line
                desc_lines.extend(wrap_text(line, term_width))
        
        max_len = max(len(line) for line in desc_lines) if desc_lines else 0
        width = min(max(max_len + 4, 40), term_width)  # Adaptive width within terminal bounds
        
        # Top border with left-aligned "Description" label
        label = "Description"
        label_padding = " " * (4 - len(label) // 2)
        top_border = f"╭─{label_padding}{label}─{'─' * (width - len(label) - 6)}╮"
        print(f"{Style.BRIGHT}{top_border}{Style.RESET_ALL}")
        
        # Content lines with proper padding
        for line in desc_lines:
            padded_line = line.ljust(width - 2)
            print(f"{Style.BRIGHT}│{padded_line}│{Style.RESET_ALL}")
        
        # Bottom border
        print(f"{Style.BRIGHT}╰{'─' * (width - 2)}╯{Style.RESET_ALL}")
    
    if skip_confirm:
        return True

    print(f"\n{Fore.CYAN}Create commit? [Y/n]: {Style.RESET_ALL}", end="")
    confirm = input().strip().lower()
    return confirm in ("", "y", "yes")


def main():
    """Main function"""
    colorama_init(autoreset=True)
    parser = argparse.ArgumentParser(description="Git Auto Commit - AI-powered commit message generation")
    parser.add_argument("-d", "--debug", action="store_true", help="Enable debug logging")
    parser.add_argument("-y", "--yes", action="store_true", help="Skip confirmation")
    parser.add_argument("--dry-run", action="store_true", help="Generate and print commit message without committing")
    parser.add_argument("--test-api", action="store_true", help="Test API connection")
    parser.add_argument("--test", action="store_true", help="Run a series of self-tests to check application health")
    parser.add_argument("--model", help="Override AI model from .env file (e.g., anthropic/claude-3.5-sonnet)")
    args = parser.parse_args()

    setup_logging(args.debug)

    if args.test_api:
        api_client.test_api_key()
        return

    if args.test:
        print("Running application self-tests...")
        all_passed = True

        # 1. Check for git repo
        print("\n1. Checking for Git repository...")
        _, code = git_utils.run_command(["git", "rev-parse", "--git-dir"])
        if code != 0:
            print(f"{Fore.RED}✗ FAIL: Not a Git repository.")
            all_passed = False
        else:
            print(f"{Fore.GREEN}✓ OK: Git repository found.")

        # 2. Check for API Key
        print("\n2. Checking for OPENROUTER_API_KEY...")
        api_key = os.getenv("OPENROUTER_API_KEY")
        if not api_key:
            print(f"{Fore.RED}✗ FAIL: OPENROUTER_API_KEY environment variable not set.")
            all_passed = False
        else:
            print(f"{Fore.GREEN}✓ OK: OPENROUTER_API_KEY is set.")

        # 3. Check git_utils.get_git_diff functionality
        print("\n3. Checking for staged files (via git_utils)...")
        staged_files, code = git_utils.run_command(["git", "diff", "--cached", "--name-only"])
        if code != 0:
            print(f"{Fore.RED}✗ FAIL: Command 'git diff --cached --name-only' failed.")
            all_passed = False
        else:
            print(f"{Fore.GREEN}✓ OK: Can check for staged files.")
            if not staged_files.strip():
                print(f"{Fore.YELLOW}NOTE: No files are currently staged.")

        # 4. Run unit tests
        print("\n4. Running unit tests with pytest...")
        _, code = git_utils.run_command(["pytest"], show_output=True)
        if code != 0:
            print(f"{Fore.RED}✗ FAIL: Unit test suite failed.{Style.RESET_ALL}")
            all_passed = False
        else:
            print(f"{Fore.GREEN}✓ OK: Unit test suite passed.{Style.RESET_ALL}")

        if all_passed:
            print(f"\n{Fore.GREEN}{Style.BRIGHT}All self-tests passed!{Style.RESET_ALL}")
            sys.exit(0)
        else:
            print(f"\n{Fore.RED}{Style.BRIGHT}Some self-tests failed.{Style.RESET_ALL}")
            sys.exit(1)

    if args.debug:
        logger.info("Git Auto Commit: generating commit for staged files...")

    # Check if we're in a git repository
    _, code = git_utils.run_command(["git", "rev-parse", "--git-dir"])
    if code != 0:
        print(f"{Fore.RED}Error: git repository not found.")
        sys.exit(1)

    model_name = args.model or os.getenv("OPENROUTER_MODEL", "anthropic/claude-3.5-sonnet")
    if args.debug:
        logger.debug(f"Using model: {model_name}")

    spinner = Halo(text=f" Fetching info for model '{model_name}'...", spinner="dots")
    spinner.start()
    model_info = api_client.get_model_info(model_name)
    if model_info:
        spinner.succeed("✓ Model info fetched.")
    else:
        spinner.fail("✗ Failed to fetch model info.")
        sys.exit(1)

    diff = git_utils.get_git_diff()
    if not diff:
        sys.exit(1)

    while True:
        spinner = Halo(text="Generating commit message with AI...", spinner="dots")
        spinner.start()
        result = api_client.generate_commit_message(diff, model_info)
        if result:
            spinner.succeed("✓ Commit message generated.")
            commit_msg, description = result
            if args.debug:
                logger.debug(f"Parsed commit message: '{commit_msg}'")
                if description:
                    logger.debug(f"Parsed description: '{description[:100]}...'")
        else:
            spinner.fail("✗ Failed to generate commit message.")

        if not result:
            print(f"{Fore.RED}Try: python3 main.py --test-api")
            sys.exit(1)

        commit_msg, description = result

        if args.dry_run:
            print(f"\n{Style.BRIGHT}╭─ Dry Run: Commit Message ─╮")
            print(f"│ {Fore.YELLOW}Message:{Style.RESET_ALL} {Fore.GREEN}{commit_msg}")
            if description:
                print(f"│ {Fore.YELLOW}Description:{Style.RESET_ALL}\n{Fore.CYAN}{description}")
            print(f"{Style.BRIGHT}╰──────────────────────────╯")
            sys.exit(0)

        if show_confirmation(commit_msg, description, args.yes):
            success = git_utils.commit_changes(commit_msg, description)
            if success:
                print(f"{Fore.GREEN}Done!")
            else:
                sys.exit(1)
            break
        else:
            retry_input = input("Retry generating commit message? [y/N]: ").lower()
            if retry_input in ("y", "yes"):
                print(f"{Fore.YELLOW}Regenerating commit message...")
                continue
            else:
                print(f"{Fore.YELLOW}Commit cancelled.")
                sys.exit(0)


if __name__ == "__main__":
    main()
